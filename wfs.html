<!DOCTYPE html>
<html>
<head>
    <title>OS Features API | BBOX Example | Mapbox GL JS</title>
    <meta charset='utf-8' />
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.54.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.54.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>

<div id='map'></div>

<script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
<script>

    var apiKey = 'asqMFGj4Kjr76hLWPD2JI69BqQTmAATs';

    var serviceUrl = 'https://osdatahubapi.os.uk/OSMapsAPI/wmts/v1';

    // Define (WMTS) parameters object.
    var wmtsParams = {
        key: apiKey,
        service: 'WMTS',
        request: 'GetTile',
        version: '2.0.0',
        height: 256,
        width: 256,
        outputFormat: 'image/png',
        style: 'default',
        layer: 'Light_3857',
        tileMatrixSet: 'EPSG:3857',
        tileMatrix: '{z}',
        tileRow: '{y}',
        tileCol: '{x}'
    };

    // Construct query string parameters from object.
    var queryString = Object.keys(wmtsParams).map(function(key) {
        return key + '=' + wmtsParams[key];
    }).join('&');

    // Create a map style object using the OS Maps API WMTS.
    var style = {
        'version': 8,
        'sources': {
            'raster-tiles': {
                'type': 'raster',
                'tiles': [ serviceUrl + '?' + queryString ],
                'tileSize': 256,
                'maxzoom': 20
            }
        },
        'layers': [{
            'id': 'os-maps-wmts',
            'type': 'raster',
            'source': 'raster-tiles'
        }]
    }

    // Initialize the map object.
    var map = new mapboxgl.Map({
        container: 'map',
        minZoom: 7,
        maxZoom: 15.5,
        style: style,
        center: [ -1.356, 50.950 ],
        zoom: 12
    });

    // Add navigation control (excluding compass button) to the map.
    map.addControl(new mapboxgl.NavigationControl({
        showCompass: true
    }));

    // Add attribution control to the map.
    map.addControl(new mapboxgl.AttributionControl({
        customAttribution: '&copy; Crown copyright and database rights ' + new Date().getFullYear() + ' Ordnance Survey.'
    }));

    // Add event which waits for the map to be loaded.
    map.on('load', function() {
        // Add an empty GeoJSON style layer for the Airport features.
        map.addLayer({
            "id": "airports",
            "type": "fill",
            "source": {
                "type": "geojson",
                "data": {
                    "type": "FeatureCollection",
                    "features": []
                }
            },
            "layout": {},
            "paint": {
                "fill-color": "#9900ff",
                "fill-opacity": 0.4
            }
        });

        // Get the visible map bounds (BBOX).
        var bounds = map.getBounds();

        getFeatures(bounds);

        // Add event which will be triggered when the map has finshed moving (pan + zoom).
        // Implements a simple strategy to only request data when the map viewport invalidates
        // certain bounds.
        map.on('moveend', function() {
            var bounds1 = new mapboxgl.LngLatBounds(bounds.getSouthWest(), bounds.getNorthEast()),
                bounds2 = map.getBounds();

            if( JSON.stringify(bounds) !== JSON.stringify(bounds1.extend(bounds2)) ) {
                bounds = bounds2;
                getFeatures(bounds);
            }
        });

        // When a click event occurs on a feature in the 'airports' layer, open a popup at
        // the location of the click, with description HTML from its properties.
        map.on('click', 'airports', function(e) {
            new mapboxgl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(e.features[0].properties.DistinctiveName1)
                .addTo(map);
        });

        // Change the cursor to a pointer when the mouse is over the 'airports' layer.
        map.on('mouseenter', 'airports', function () {
            map.getCanvas().style.cursor = 'pointer';
        });

        // Change the cursor back to a pointer when it leaves the 'airports' layer.
        map.on('mouseleave', 'airports', function () {
            map.getCanvas().style.cursor = '';
        });
    });

    /**
     * Get features from the WFS.
     */
    function getFeatures(bounds) {
        // Convert the bounds to a formatted string.
        var sw = bounds.getSouthWest().lng + ',' + bounds.getSouthWest().lat,
            ne = bounds.getNorthEast().lng + ',' + bounds.getNorthEast().lat;

        var coords = sw + ' ' + ne;

        // Create an OGC XML filter parameter value which will select the Airport
        // features (site function) intersecting the BBOX coordinates.
        var xml = '<ogc:Filter>';
        xml += '<ogc:And>';
        xml += '<ogc:BBOX>';
        xml += '<ogc:PropertyName>SHAPE</ogc:PropertyName>';
        xml += '<gml:Box srsName="urn:ogc:def:crs:EPSG::4326">';
        xml += '<gml:coordinates>' + coords + '</gml:coordinates>';
        xml += '</gml:Box>';
        xml += '</ogc:BBOX>';
        xml += '<ogc:PropertyIsEqualTo>';
        xml += '<ogc:PropertyName>SiteFunction</ogc:PropertyName>';
        xml += '<ogc:Literal>Airport</ogc:Literal>';
        xml += '</ogc:PropertyIsEqualTo>';
        xml += '</ogc:And>';
        xml += '</ogc:Filter>';

        // Define (WFS) parameters object.
        var wfsParams = {
            key: apiKey,
            service: 'WFS',
            request: 'GetFeature',
            version: '2.0.0',
            typeNames: 'Sites_FunctionalSite',
            outputFormat: 'GEOJSON',
            srsName: 'urn:ogc:def:crs:EPSG::4326',
            filter: xml
        };

        // Use fetch() method to request GeoJSON data from the OS Features API.
        // If successful - set the GeoJSON data for the 'airports' layer and re-render
        // the map.
        fetch(getUrl(wfsParams))
            .then(response => response.json())
            .then((data) => {
                // {Turf.js} Rewind polygons to follow the right-hand rule, i.e. exterior
                // rings are counterclockwise and inner rings [holes] are clockwise; plus
                // ensure the geometry has no self-intersections.
                var result = turf.unkinkPolygon(turf.rewind(data));
                map.getSource('airports').setData(result);
            });
    }

    /**
     * Return URL with encoded parameters.
     */
    function getUrl(params) {
        var encodedParameters = Object.keys(params)
            .map(paramName => paramName + '=' + encodeURI(params[paramName]))
            .join('&');

        return 'https://osdatahubapi.os.uk/OSFeaturesAPI/wfs/v1?' + encodedParameters;
    }

</script>

</body>
</html>
